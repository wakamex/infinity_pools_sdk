{
  "tasks": [
    {
      "id": 1,
      "title": "Setup Project Structure and Dependencies",
      "description": "Initialize the SDK project with proper structure, dependencies, and development tools.",
      "details": "1. Create project directory structure:\n   - infinity_pools_sdk/\n     - __init__.py\n     - core/\n     - models/\n     - utils/\n     - erc/\n     - tests/\n2. Setup package configuration (setup.py, pyproject.toml)\n3. Configure development tools:\n   - pytest for testing\n4. Define dependencies in pyproject.toml (e.g., using `uv add`):\n   - web3>=7.11.1\n5. Setup CI configuration with GitHub Actions\n6. Create initial README.md with project overview",
      "testStrategy": "Verify project structure is correctly set up by running:\n1. Installation test: `uv pip install -e '.[test]'`\n2. Import test: `import infinity_pools_sdk`\n3. Ensure CI pipeline passes initial checks",
      "priority": "high",
      "dependencies": [],
      "status": "done",
      "subtasks": []
    },
    {
      "id": 2,
      "title": "Implement Quad Type Conversion Utilities",
      "description": "Create utilities for converting between Solidity's Quad fixed-point numbers and Python's Decimal type.",
      "details": "Create a module `utils/quad.py` with the following functions:\n\n```python\nfrom decimal import Decimal\n\nQUAD_PRECISION = 18  # Number of decimal places in Quad type\n\ndef decimal_to_quad(value: Decimal) -> int:\n    \"\"\"Convert a Python Decimal to a Quad fixed-point integer representation\"\"\"\n    scaled = value * (10 ** QUAD_PRECISION)\n    return int(scaled)\n\ndef quad_to_decimal(value: int) -> Decimal:\n    \"\"\"Convert a Quad fixed-point integer to a Python Decimal\"\"\"\n    return Decimal(value) / (10 ** QUAD_PRECISION)\n\ndef format_quad_for_display(value: int, decimals: int = 6) -> str:\n    \"\"\"Format a Quad value for human-readable display with specified precision\"\"\"\n    decimal_value = quad_to_decimal(value)\n    return f\"{decimal_value:.{decimals}f}\"\n```\n\nImplement additional helper functions for Quad arithmetic operations that maintain precision.",
      "testStrategy": "1. Write unit tests in `tests/test_quad.py` that verify:\n   - Conversion from Decimal to Quad and back preserves value\n   - Edge cases: very large numbers, very small numbers, zero\n   - Negative values\n   - Rounding behavior\n2. Test with known values from the Infinity Pools contract\n3. Verify precision is maintained through multiple operations",
      "priority": "high",
      "dependencies": [
        1
      ],
      "status": "done",
      "subtasks": []
    },
    {
      "id": 3,
      "title": "Implement ABI and Address Configuration Management",
      "description": "Create a configuration system to manage contract ABIs and addresses across different networks.",
      "details": "1. Create `utils/config.py` module with:\n\n```python\nimport json\nimport os\nfrom pathlib import Path\nfrom typing import Dict, Any, Optional\n\nNETWORKS = {\n    'mainnet': 1,\n    'goerli': 5,\n    'sepolia': 11155111,\n    'arbitrum': 42161,\n    'optimism': 10,\n    # Add other supported networks\n}\n\nclass ContractConfig:\n    def __init__(self, network_name: str = 'mainnet'):\n        self.network_name = network_name\n        self.network_id = NETWORKS.get(network_name, 1)\n        self._load_addresses()\n        self._load_abis()\n    \n    def _load_addresses(self):\n        \"\"\"Load contract addresses for the selected network\"\"\"\n        # Load from a JSON file or embedded dictionary\n        addresses_file = Path(__file__).parent.parent / 'data' / f'addresses_{self.network_name}.json'\n        if addresses_file.exists():\n            with open(addresses_file, 'r') as f:\n                self.addresses = json.load(f)\n        else:\n            # Fallback to embedded addresses\n            self.addresses = DEFAULT_ADDRESSES.get(self.network_name, {})\n    \n    def _load_abis(self):\n        \"\"\"Load contract ABIs\"\"\"\n        self.abis = {}\n        abi_dir = Path(__file__).parent.parent / 'data' / 'abis'\n        for abi_file in abi_dir.glob('*.json'):\n            contract_name = abi_file.stem\n            with open(abi_file, 'r') as f:\n                self.abis[contract_name] = json.load(f)\n    \n    def get_address(self, contract_name: str) -> str:\n        \"\"\"Get address for a specific contract\"\"\"\n        return self.addresses.get(contract_name, '')\n    \n    def get_abi(self, contract_name: str) -> list:\n        \"\"\"Get ABI for a specific contract\"\"\"\n        return self.abis.get(contract_name, [])\n```\n\n2. Create a data directory structure:\n   - data/\n     - abis/\n       - InfinityPoolsPeriphery.json\n       - ERC20.json\n       - ERC721.json\n     - addresses_mainnet.json\n     - addresses_goerli.json\n     - etc.\n\n3. Implement functions to update configurations at runtime",
      "testStrategy": "1. Write unit tests in `tests/test_config.py` that verify:\n   - Configuration loads correctly for different networks\n   - ABIs are properly parsed\n   - Contract addresses are correctly retrieved\n   - Error handling for missing contracts/networks\n2. Test with mock configuration files\n3. Verify configuration can be updated at runtime",
      "priority": "high",
      "dependencies": [
        1
      ],
      "status": "done",
      "subtasks": []
    },
    {
      "id": 4,
      "title": "Implement Core Connector Module",
      "description": "Create the core connector module that manages Web3.py connection and transaction signing.",
      "details": "Create `core/connector.py` with the following components:\n\n```python\nfrom typing import Optional, Union, Dict, Any\nfrom web3 import Web3, HTTPProvider\nfrom web3.middleware import geth_poa_middleware\nfrom eth_account import Account\nfrom eth_account.signers.local import LocalAccount\nfrom ..utils.config import ContractConfig, NETWORKS\n\nclass InfinityPoolsConnector:\n    def __init__(self, \n                 rpc_url: Optional[str] = None,\n                 network: str = 'mainnet',\n                 private_key: Optional[str] = None):\n        \"\"\"Initialize the connector with RPC URL and optional private key\"\"\"\n        self.network = network\n        self.config = ContractConfig(network)\n        \n        # Setup Web3 connection\n        if rpc_url is None:\n            rpc_url = self._get_default_rpc()\n        self.w3 = Web3(HTTPProvider(rpc_url))\n        \n        # Add middleware for POA networks if needed\n        if network in ['goerli', 'sepolia']:\n            self.w3.middleware_onion.inject(geth_poa_middleware, layer=0)\n        \n        # Setup account if private key provided\n        self.account: Optional[LocalAccount] = None\n        if private_key:\n            self.load_account(private_key)\n    \n    def _get_default_rpc(self) -> str:\n        \"\"\"Get default RPC URL from environment variables\"\"\"\n        import os\n        env_var = f\"INFINITY_POOLS_RPC_{self.network.upper()}\"\n        rpc_url = os.environ.get(env_var)\n        if not rpc_url:\n            raise ValueError(f\"No RPC URL provided and no {env_var} environment variable found\")\n        return rpc_url\n    \n    def load_account(self, private_key: str) -> LocalAccount:\n        \"\"\"Load an Ethereum account from a private key\"\"\"\n        if private_key.startswith('0x'):\n            private_key = private_key[2:]\n        self.account = Account.from_key(private_key)\n        return self.account\n    \n    def get_contract(self, contract_name: str):\n        \"\"\"Get a contract instance by name\"\"\"\n        address = self.config.get_address(contract_name)\n        abi = self.config.get_abi(contract_name)\n        if not address or not abi:\n            raise ValueError(f\"Contract {contract_name} not found in configuration\")\n        return self.w3.eth.contract(address=address, abi=abi)\n    \n    def send_transaction(self, tx_params: Dict[str, Any]) -> str:\n        \"\"\"Sign and send a transaction\"\"\"\n        if not self.account:\n            raise ValueError(\"No account loaded. Call load_account() first.\")\n        \n        # Ensure gas parameters are set\n        if 'gas' not in tx_params:\n            tx_params['gas'] = self.w3.eth.estimate_gas(tx_params)\n        if 'gasPrice' not in tx_params and 'maxFeePerGas' not in tx_params:\n            tx_params['gasPrice'] = self.w3.eth.gas_price\n        \n        # Set nonce if not provided\n        if 'nonce' not in tx_params:\n            tx_params['nonce'] = self.w3.eth.get_transaction_count(self.account.address)\n        \n        # Sign transaction\n        signed_tx = self.account.sign_transaction(tx_params)\n        \n        # Send transaction\n        tx_hash = self.w3.eth.send_raw_transaction(signed_tx.rawTransaction)\n        return tx_hash.hex()\n    \n    def wait_for_transaction(self, tx_hash: str, timeout: int = 120) -> Dict[str, Any]:\n        \"\"\"Wait for a transaction to be mined and return the receipt\"\"\"\n        tx_hash_bytes = Web3.to_bytes(hexstr=tx_hash)\n        receipt = self.w3.eth.wait_for_transaction_receipt(tx_hash_bytes, timeout=timeout)\n        return dict(receipt)\n```\n\nAlso implement a simplified version for read-only operations.",
      "testStrategy": "1. Write unit tests in `tests/test_connector.py` that verify:\n   - Connection to different networks\n   - Account loading and address derivation\n   - Contract instance creation\n   - Transaction parameter preparation\n   - Mock transaction sending and receipt handling\n2. Use a local Ethereum node or mock provider for testing\n3. Test error handling for invalid inputs and network issues",
      "priority": "high",
      "dependencies": [
        3
      ],
      "status": "done",
      "subtasks": []
    },
    {
      "id": 5,
      "title": "Implement ERC20 and ERC721 Helper Modules",
      "description": "Create wrapper modules for common ERC20 and ERC721 token interactions.",
      "details": "1. Create `erc/erc20.py` with the following:\n\n```python\nfrom decimal import Decimal\nfrom typing import Optional, Dict, Any\nfrom ..core.connector import InfinityPoolsConnector\n\nclass ERC20Helper:\n    def __init__(self, connector: InfinityPoolsConnector):\n        self.connector = connector\n        self.w3 = connector.w3\n    \n    def get_contract(self, token_address: str):\n        \"\"\"Get ERC20 contract instance for a specific token address\"\"\"\n        return self.w3.eth.contract(address=token_address, abi=self.connector.config.get_abi('ERC20'))\n    \n    def balance_of(self, token_address: str, address: Optional[str] = None) -> Decimal:\n        \"\"\"Get token balance for an address (defaults to loaded account)\"\"\"\n        if address is None:\n            if not self.connector.account:\n                raise ValueError(\"No account loaded and no address provided\")\n            address = self.connector.account.address\n        \n        contract = self.get_contract(token_address)\n        balance_wei = contract.functions.balanceOf(address).call()\n        decimals = contract.functions.decimals().call()\n        return Decimal(balance_wei) / (10 ** decimals)\n    \n    def approve(self, token_address: str, spender_address: str, amount: Decimal) -> str:\n        \"\"\"Approve spender to use tokens\"\"\"\n        if not self.connector.account:\n            raise ValueError(\"No account loaded for transaction\")\n        \n        contract = self.get_contract(token_address)\n        decimals = contract.functions.decimals().call()\n        amount_wei = int(amount * (10 ** decimals))\n        \n        tx_params = {\n            'from': self.connector.account.address,\n        }\n        \n        tx = contract.functions.approve(spender_address, amount_wei).build_transaction(tx_params)\n        return self.connector.send_transaction(tx)\n    \n    def allowance(self, token_address: str, owner_address: str, spender_address: str) -> Decimal:\n        \"\"\"Check allowance for a spender\"\"\"\n        contract = self.get_contract(token_address)\n        allowance_wei = contract.functions.allowance(owner_address, spender_address).call()\n        decimals = contract.functions.decimals().call()\n        return Decimal(allowance_wei) / (10 ** decimals)\n```\n\n2. Create `erc/erc721.py` with similar functions for NFT operations:\n\n```python\nfrom typing import Optional, Dict, Any, List\nfrom ..core.connector import InfinityPoolsConnector\n\nclass ERC721Helper:\n    def __init__(self, connector: InfinityPoolsConnector):\n        self.connector = connector\n        self.w3 = connector.w3\n    \n    def get_contract(self, nft_address: str):\n        \"\"\"Get ERC721 contract instance for a specific NFT address\"\"\"\n        return self.w3.eth.contract(address=nft_address, abi=self.connector.config.get_abi('ERC721'))\n    \n    def owner_of(self, nft_address: str, token_id: int) -> str:\n        \"\"\"Get owner of a specific NFT token\"\"\"\n        contract = self.get_contract(nft_address)\n        return contract.functions.ownerOf(token_id).call()\n    \n    def balance_of(self, nft_address: str, address: Optional[str] = None) -> int:\n        \"\"\"Get number of NFTs owned by an address\"\"\"\n        if address is None:\n            if not self.connector.account:\n                raise ValueError(\"No account loaded and no address provided\")\n            address = self.connector.account.address\n        \n        contract = self.get_contract(nft_address)\n        return contract.functions.balanceOf(address).call()\n    \n    def get_approved(self, nft_address: str, token_id: int) -> str:\n        \"\"\"Get approved address for a token\"\"\"\n        contract = self.get_contract(nft_address)\n        return contract.functions.getApproved(token_id).call()\n    \n    def approve(self, nft_address: str, to_address: str, token_id: int) -> str:\n        \"\"\"Approve address to transfer specific NFT\"\"\"\n        if not self.connector.account:\n            raise ValueError(\"No account loaded for transaction\")\n        \n        contract = self.get_contract(nft_address)\n        tx_params = {\n            'from': self.connector.account.address,\n        }\n        \n        tx = contract.functions.approve(to_address, token_id).build_transaction(tx_params)\n        return self.connector.send_transaction(tx)\n    \n    def set_approval_for_all(self, nft_address: str, operator_address: str, approved: bool) -> str:\n        \"\"\"Set or revoke approval for all NFTs\"\"\"\n        if not self.connector.account:\n            raise ValueError(\"No account loaded for transaction\")\n        \n        contract = self.get_contract(nft_address)\n        tx_params = {\n            'from': self.connector.account.address,\n        }\n        \n        tx = contract.functions.setApprovalForAll(operator_address, approved).build_transaction(tx_params)\n        return self.connector.send_transaction(tx)\n```",
      "testStrategy": "1. Write unit tests in `tests/test_erc20.py` and `tests/test_erc721.py` that verify:\n   - Token balance retrieval\n   - Approval functionality\n   - Allowance checking\n   - NFT ownership verification\n   - Error handling for invalid addresses\n2. Use mock contracts for testing\n3. Test with real token addresses on test networks\n4. Verify gas estimation and transaction building",
      "priority": "medium",
      "dependencies": [
        4
      ],
      "status": "done",
      "subtasks": []
    },
    {
      "id": 6,
      "title": "Implement Data Models for Contract Parameters",
      "description": "Create Python classes representing Solidity structs used in the Infinity Pools protocol.",
      "details": "Create `models/data_models.py` with the following classes:\n\n```python\nfrom dataclasses import dataclass\nfrom typing import List, Optional, Union, Dict, Any\nfrom decimal import Decimal\nfrom ..utils.quad import decimal_to_quad, quad_to_decimal\n\n@dataclass\nclass AddLiquidityParams:\n    \"\"\"Represents the AddLiquidityParams struct in the Infinity Pools contract\"\"\"\n    token0: str  # Address of token0\n    token1: str  # Address of token1\n    fee: int  # Fee tier (e.g., 500, 3000, 10000)\n    tickLower: int  # Lower tick boundary\n    tickUpper: int  # Upper tick boundary\n    amount0Desired: Decimal  # Desired amount of token0\n    amount1Desired: Decimal  # Desired amount of token1\n    amount0Min: Decimal  # Minimum amount of token0\n    amount1Min: Decimal  # Minimum amount of token1\n    recipient: str  # Address to receive the position NFT\n    deadline: int  # Transaction deadline timestamp\n    \n    def to_contract_tuple(self, token0_decimals: int = 18, token1_decimals: int = 18) -> tuple:\n        \"\"\"Convert to tuple format expected by the contract\"\"\"\n        return (\n            self.token0,\n            self.token1,\n            self.fee,\n            self.tickLower,\n            self.tickUpper,\n            int(self.amount0Desired * (10 ** token0_decimals)),\n            int(self.amount1Desired * (10 ** token1_decimals)),\n            int(self.amount0Min * (10 ** token0_decimals)),\n            int(self.amount1Min * (10 ** token1_decimals)),\n            self.recipient,\n            self.deadline\n        )\n\n@dataclass\nclass SwapInfo:\n    \"\"\"Represents the SwapInfo struct in the Infinity Pools contract\"\"\"\n    tokenIn: str  # Address of input token\n    tokenOut: str  # Address of output token\n    fee: int  # Fee tier\n    recipient: str  # Address to receive output tokens\n    amountIn: Decimal  # Amount of input tokens\n    amountOutMinimum: Decimal  # Minimum amount of output tokens\n    sqrtPriceLimitX96: int  # Price limit for the swap\n    \n    def to_contract_tuple(self, token_in_decimals: int = 18) -> tuple:\n        \"\"\"Convert to tuple format expected by the contract\"\"\"\n        return (\n            self.tokenIn,\n            self.tokenOut,\n            self.fee,\n            self.recipient,\n            int(self.amountIn * (10 ** token_in_decimals)),\n            int(self.amountOutMinimum),  # Already in wei\n            self.sqrtPriceLimitX96\n        )\n\n@dataclass\nclass BatchActionsParams:\n    \"\"\"Represents parameters for batch actions on swappers\"\"\"\n    swapperIds: List[int]  # List of swapper IDs\n    actions: List[int]  # List of actions to perform\n    data: List[bytes]  # Additional data for each action\n    \n    def to_contract_tuple(self) -> tuple:\n        \"\"\"Convert to tuple format expected by the contract\"\"\"\n        return (\n            self.swapperIds,\n            self.actions,\n            self.data\n        )\n\n# Add more data models for other contract structs as needed\n```\n\nAlso implement utility functions for encoding/decoding NFT position IDs:\n\n```python\ndef encode_position_id(token0: str, token1: str, fee: int, tick_lower: int, tick_upper: int) -> int:\n    \"\"\"Encode position parameters into a tokenId\"\"\"\n    # This is a simplified version - actual implementation would need to match the contract logic\n    # for encoding tokenIds\n    pass\n\ndef decode_position_id(token_id: int) -> Dict[str, Any]:\n    \"\"\"Decode a tokenId into its component parts\"\"\"\n    # This is a simplified version - actual implementation would need to match the contract logic\n    # for decoding tokenIds\n    pass\n```",
      "testStrategy": "1. Write unit tests in `tests/test_data_models.py` that verify:\n   - Correct conversion between Python types and contract parameter formats\n   - Handling of different token decimals\n   - Edge cases (very large/small values)\n   - Encoding/decoding of position IDs\n2. Test with known values from the Infinity Pools contract\n3. Verify serialization/deserialization maintains data integrity",
      "priority": "high",
      "dependencies": [
        2
      ],
      "status": "done",
      "subtasks": []
    },
    {
      "id": 7,
      "title": "Implement High-Level SDK for User Interactions",
      "description": "Create a user-friendly SDK class (`InfinityPoolsSDK` in `infinity_pools_sdk/sdk.py`) that provides high-level methods for common Infinity Pools protocol operations. This class will abstract away direct contract calls and data complexities, simplifying integration for developers.",
      "status": "pending",
      "dependencies": [
        4,
        5,
        6
      ],
      "priority": "high",
      "details": "Create `infinity_pools_sdk/sdk.py` with the following implementation:\n\n```python\nfrom typing import Dict, Any, List, Optional, Union, Tuple\nfrom decimal import Decimal\nfrom web3.contract import Contract\nfrom .core.connector import ContractConnector\nfrom .models.data_models import AddLiquidityParams, SwapInfo, BatchActionsParams\nfrom .erc.erc20 import ERC20Helper\nfrom .core.periphery import InfinityPoolsPeriphery\n\nclass InfinityPoolsSDK:\n    def __init__(self, connector: ContractConnector):\n        self.connector = connector\n        self.w3 = connector.w3\n        self.periphery = InfinityPoolsPeriphery(connector)\n        self.erc20 = ERC20Helper(connector)\n    \n    def get_pool_address(self, token0: str, token1: str, fee: int) -> str:\n        \"\"\"Get the address of a pool for the given tokens and fee tier\"\"\"\n        return self.periphery.get_pool_address(token0, token1, fee)\n    \n    def get_pool_details(self, token0: str, token1: str, fee: int) -> Dict[str, Any]:\n        \"\"\"Get detailed information about a specific pool\"\"\"\n        pool_address = self.get_pool_address(token0, token1, fee)\n        # Fetch pool details like liquidity, current price, etc.\n        # This would involve calling various view functions on the pool contract\n        return {\n            'address': pool_address,\n            # Additional pool details would be added here\n        }\n    \n    def get_user_positions(self, user_address: Optional[str] = None) -> List[Dict[str, Any]]:\n        \"\"\"Get all liquidity positions owned by the user\"\"\"\n        if not user_address and not self.connector.account:\n            raise ValueError(\"No user address provided and no account loaded\")\n        \n        address = user_address or self.connector.account.address\n        # Fetch positions from the contract\n        # This would involve querying the NFT contract for tokens owned by the user\n        # and then getting details for each position\n        \n        return []\n    \n    def add_liquidity(self, \n                      token0: str, \n                      token1: str, \n                      fee: int,\n                      amount0: Decimal,\n                      amount1: Decimal,\n                      slippage_tolerance: Decimal = Decimal('0.01'),\n                      recipient: Optional[str] = None,\n                      deadline: Optional[int] = None) -> Dict[str, Any]:\n        \"\"\"Add liquidity to a pool and receive an LP NFT\"\"\"\n        if not self.connector.account:\n            raise ValueError(\"No account loaded for transaction\")\n        \n        # Ensure token0 < token1 by address value\n        if int(token0, 16) > int(token1, 16):\n            token0, token1 = token1, token0\n            amount0, amount1 = amount1, amount0\n        \n        # Create AddLiquidityParams object\n        params = AddLiquidityParams(\n            token0=token0,\n            token1=token1,\n            fee=fee,\n            amount0Desired=amount0,\n            amount1Desired=amount1,\n            amount0Min=amount0 * (1 - slippage_tolerance),\n            amount1Min=amount1 * (1 - slippage_tolerance),\n            recipient=recipient or self.connector.account.address,\n            deadline=deadline or (self.w3.eth.get_block('latest').timestamp + 1200)  # 20 minutes from now\n        )\n        \n        # Call periphery contract\n        return self.periphery.add_liquidity(params)\n    \n    def remove_liquidity(self, \n                         token_id: int,\n                         liquidity_percentage: Decimal = Decimal('1'),\n                         recipient: Optional[str] = None,\n                         deadline: Optional[int] = None) -> Dict[str, Any]:\n        \"\"\"Remove liquidity from a position\"\"\"\n        if not self.connector.account:\n            raise ValueError(\"No account loaded for transaction\")\n        \n        # Implementation would call the appropriate periphery contract method\n        # to remove liquidity from the position\n        \n        return {}\n    \n    def collect_fees(self, \n                    token_id: int,\n                    recipient: Optional[str] = None) -> Dict[str, Any]:\n        \"\"\"Collect accumulated fees from a position\"\"\"\n        if not self.connector.account:\n            raise ValueError(\"No account loaded for transaction\")\n        \n        # Implementation would call the appropriate periphery contract method\n        # to collect fees from the position\n        \n        return {}\n    \n    def swap_exact_input(self,\n                         token_in: str,\n                         token_out: str,\n                         amount_in: Decimal,\n                         min_amount_out: Optional[Decimal] = None,\n                         recipient: Optional[str] = None,\n                         deadline: Optional[int] = None) -> Dict[str, Any]:\n        \"\"\"Swap an exact amount of input tokens for a minimum amount of output tokens\"\"\"\n        if not self.connector.account:\n            raise ValueError(\"No account loaded for transaction\")\n        \n        # Create SwapInfo object\n        swap_info = SwapInfo(\n            tokenIn=token_in,\n            tokenOut=token_out,\n            amountIn=amount_in,\n            amountOutMinimum=min_amount_out or Decimal('0'),  # Default to 0 if not specified\n            recipient=recipient or self.connector.account.address,\n            deadline=deadline or (self.w3.eth.get_block('latest').timestamp + 1200)  # 20 minutes from now\n        )\n        \n        # Call periphery contract\n        return self.periphery.swap_deposit(swap_info)\n    \n    # Additional methods for other protocol operations would be implemented here\n    # - borrow\n    # - repay\n    # - reflow\n    # - etc.\n```\n\nAlso create `infinity_pools_sdk/core/periphery.py` with the following implementation:\n\n```python\nfrom typing import Dict, Any, List, Optional, Union, Tuple\nfrom decimal import Decimal\nfrom web3.contract import Contract\nfrom .connector import ContractConnector\nfrom ..models.data_models import AddLiquidityParams, SwapInfo, BatchActionsParams\nfrom ..erc.erc20 import ERC20Helper\n\nclass InfinityPoolsPeriphery:\n    def __init__(self, connector: ContractConnector):\n        self.connector = connector\n        self.w3 = connector.w3\n        self.contract = self._get_periphery_contract()\n        self.erc20 = ERC20Helper(connector)\n    \n    def _get_periphery_contract(self) -> Contract:\n        \"\"\"Get the InfinityPoolsPeriphery contract instance\"\"\"\n        return self.connector.get_contract('InfinityPoolsPeriphery')\n    \n    def get_pool_address(self, token0: str, token1: str, fee: int) -> str:\n        \"\"\"Get the address of a pool for the given tokens and fee tier\"\"\"\n        # Ensure token0 < token1 by address value\n        if int(token0, 16) > int(token1, 16):\n            token0, token1 = token1, token0\n        \n        return self.contract.functions.getPoolAddress(token0, token1, fee).call()\n    \n    def add_liquidity(self, params: AddLiquidityParams) -> Dict[str, Any]:\n        \"\"\"Add liquidity to a pool and receive an LP NFT\"\"\"\n        if not self.connector.account:\n            raise ValueError(\"No account loaded for transaction\")\n        \n        # Get token decimals for amount conversion\n        token0_decimals = self.erc20.get_contract(params.token0).functions.decimals().call()\n        token1_decimals = self.erc20.get_contract(params.token1).functions.decimals().call()\n        \n        # Check and set approvals if needed\n        periphery_address = self.contract.address\n        \n        token0_allowance = self.erc20.allowance(\n            params.token0, \n            self.connector.account.address, \n            periphery_address\n        )\n        if token0_allowance < params.amount0Desired:\n            self.erc20.approve(params.token0, periphery_address, params.amount0Desired * 2)\n        \n        token1_allowance = self.erc20.allowance(\n            params.token1, \n            self.connector.account.address, \n            periphery_address\n        )\n        if token1_allowance < params.amount1Desired:\n            self.erc20.approve(params.token1, periphery_address, params.amount1Desired * 2)\n        \n        # Build and send transaction\n        tx_params = {\n            'from': self.connector.account.address,\n        }\n        \n        contract_params = params.to_contract_tuple(token0_decimals, token1_decimals)\n        tx = self.contract.functions.addLiquidity(contract_params).build_transaction(tx_params)\n        tx_hash = self.connector.send_transaction(tx)\n        \n        # Wait for transaction and parse result\n        receipt = self.connector.wait_for_transaction(tx_hash)\n        \n        # Parse events to get the tokenId of the minted position\n        # This is a simplified version - actual implementation would need to parse the events\n        # to extract the tokenId and other details\n        \n        return {\n            'tx_hash': tx_hash,\n            'receipt': receipt,\n            # 'token_id': token_id,  # Would be extracted from events\n            # Additional details from the transaction\n        }\n    \n    def swap_deposit(self, swap_info: SwapInfo) -> Dict[str, Any]:\n        \"\"\"Perform a swap and deposit operation\"\"\"\n        if not self.connector.account:\n            raise ValueError(\"No account loaded for transaction\")\n        \n        # Get token decimals for amount conversion\n        token_in_decimals = self.erc20.get_contract(swap_info.tokenIn).functions.decimals().call()\n        \n        # Check and set approvals if needed\n        periphery_address = self.contract.address\n        \n        token_in_allowance = self.erc20.allowance(\n            swap_info.tokenIn, \n            self.connector.account.address, \n            periphery_address\n        )\n        if token_in_allowance < swap_info.amountIn:\n            self.erc20.approve(swap_info.tokenIn, periphery_address, swap_info.amountIn * 2)\n        \n        # Build and send transaction\n        tx_params = {\n            'from': self.connector.account.address,\n        }\n        \n        contract_params = swap_info.to_contract_tuple(token_in_decimals)\n        tx = self.contract.functions.swapDeposit(contract_params).build_transaction(tx_params)\n        tx_hash = self.connector.send_transaction(tx)\n        \n        # Wait for transaction and parse result\n        receipt = self.connector.wait_for_transaction(tx_hash)\n        \n        # Parse events to get details about the swap\n        # This is a simplified version - actual implementation would need to parse the events\n        \n        return {\n            'tx_hash': tx_hash,\n            'receipt': receipt,\n            # Additional details from the transaction and events\n        }\n    \n    # Implement other periphery contract methods following the same pattern\n    # - newLoanWithSwap\n    # - batchActionsOnSwappers\n    # - reflow\n    # - collect\n    # - drain\n    # - tap\n    # etc.\n```",
      "testStrategy": "1. Write unit tests in `tests/test_sdk.py` that verify:\n   - SDK initialization and configuration\n   - Parameter preparation for contract calls\n   - Interaction with mocked `ContractConnector`\n   - Return value handling\n   - ERC20 approval management\n   - Error handling and validation\n2. Test each high-level method:\n   - `add_liquidity`\n   - `remove_liquidity`\n   - `collect_fees`\n   - `swap_exact_input`\n   - `get_pool_details`\n   - `get_user_positions`\n3. Use mock objects for the `ContractConnector` and contract instances\n4. Test parameter validation and error cases\n5. Integration tests on a testnet can be a secondary step",
      "subtasks": [
        {
          "id": 1,
          "title": "SDK: Implement remove_liquidity function",
          "description": "Implement the 'remove_liquidity' function in InfinityPoolsSDK. This allows users to withdraw their liquidity and claim accrued fees. Requires ABI definition, SDK method implementation, data model updates (if any), and unit tests.",
          "details": "",
          "status": "pending",
          "dependencies": [],
          "priority": "high",
          "parentTaskId": 7
        },
        {
          "id": 2,
          "title": "SDK: Implement collect_fees function",
          "description": "Implement the 'collect_fees' function in InfinityPoolsSDK. This allows users to claim earned fees from their LP positions without removing the underlying liquidity. Requires ABI definition, SDK method implementation, and unit tests.",
          "details": "",
          "status": "pending",
          "dependencies": [],
          "priority": "high",
          "parentTaskId": 7
        },
        {
          "id": 3,
          "title": "SDK: Implement swap_exact_input function",
          "description": "Implement the 'swap_exact_input' function in InfinityPoolsSDK. Allows users to swap a known amount of an input token for an output token. Requires ABI definition, SDK method implementation, data model updates (if any), and unit tests.",
          "details": "",
          "status": "pending",
          "dependencies": [],
          "priority": "high",
          "parentTaskId": 7
        },
        {
          "id": 4,
          "title": "SDK: Implement swap_exact_output function",
          "description": "Implement the 'swap_exact_output' function in InfinityPoolsSDK. Allows users to swap an input token for a known amount of an output token. Requires ABI definition, SDK method implementation, data model updates (if any), and unit tests.",
          "details": "",
          "status": "pending",
          "dependencies": [],
          "priority": "high",
          "parentTaskId": 7
        },
        {
          "id": 5,
          "title": "SDK: Implement get_position_details function",
          "description": "Implement 'get_position_details' in InfinityPoolsSDK. Allows users to query details of their liquidity positions (e.g., by NFT ID). Requires ABI definition/contract interaction logic for read-only calls, SDK method, data models, and tests.",
          "details": "",
          "status": "pending",
          "dependencies": [],
          "priority": "high",
          "parentTaskId": 7
        },
        {
          "id": 6,
          "title": "SDK: Implement get_pool_info function",
          "description": "Implement 'get_pool_info' in InfinityPoolsSDK. Allows querying info about a liquidity pool (e.g., reserves, price, tick). Requires ABI definition/contract interaction logic for read-only calls, SDK method, data models, and tests.",
          "details": "",
          "status": "pending",
          "dependencies": [],
          "priority": "high",
          "parentTaskId": 7
        },
        {
          "id": 7,
          "title": "SDK: Implement function to create Swapper/Leveraged Positions (e.g., shorts)",
          "description": "Implement an SDK function to create new 'Swapper' positions (leveraged positions like shorts). This involves: 1. Defining a Python data model for `NewLoanParams`. 2. Creating logic to translate user-friendly inputs (e.g., collateral, asset to short, leverage) into the complex `NewLoanParams` struct. 3. Identifying and interacting with the correct periphery contract function (likely involving `NewLoan.sol`'s `newLoan` logic). 4. Handling collateral token approvals. 5. Writing comprehensive unit tests.",
          "details": "The function should abstract the complexity of the `NewLoanParams` struct (fields: `owedPotential`, `startBin`, `strikeBin`, `tokenMix`, `lockinEnd`, `deadEra`, `token`, `twapUntil`) and derive them from simpler user inputs. Refer to `CONTRACT_DETAILS.md` around lines 703-712 for `NewLoanParams` fields. The transaction input data suggests a function selector `0x10c59026` is involved.",
          "status": "pending",
          "dependencies": [],
          "parentTaskId": 7
        }
      ]
    },
    {
      "id": 8,
      "title": "Implement Error Handling and Custom Exceptions",
      "description": "Create a robust error handling system that translates blockchain and contract errors into meaningful Python exceptions.",
      "details": "Create `utils/errors.py` with the following implementation:\n\n```python\nfrom typing import Dict, Any, Optional\nimport re\n\nclass InfinityPoolsError(Exception):\n    \"\"\"Base exception for all Infinity Pools SDK errors\"\"\"\n    pass\n\nclass ConnectionError(InfinityPoolsError):\n    \"\"\"Error connecting to Ethereum node\"\"\"\n    pass\n\nclass TransactionError(InfinityPoolsError):\n    \"\"\"Error during transaction execution\"\"\"\n    def __init__(self, message: str, tx_hash: Optional[str] = None, receipt: Optional[Dict[str, Any]] = None):\n        super().__init__(message)\n        self.tx_hash = tx_hash\n        self.receipt = receipt\n\nclass ContractError(InfinityPoolsError):\n    \"\"\"Error from contract execution\"\"\"\n    def __init__(self, message: str, error_data: Optional[str] = None):\n        super().__init__(message)\n        self.error_data = error_data\n        self.parsed_error = self._parse_error(error_data) if error_data else None\n    \n    def _parse_error(self, error_data: str) -> Dict[str, Any]:\n        \"\"\"Parse contract error data into a more readable format\"\"\"\n        # This is a simplified version - actual implementation would need to\n        # decode the error data based on contract ABI and error signatures\n        return {'raw_data': error_data}\n\nclass InsufficientLiquidityError(ContractError):\n    \"\"\"Error when there is insufficient liquidity for an operation\"\"\"\n    pass\n\nclass SlippageError(ContractError):\n    \"\"\"Error when slippage tolerance is exceeded\"\"\"\n    pass\n\nclass InvalidParameterError(InfinityPoolsError):\n    \"\"\"Error when an invalid parameter is provided\"\"\"\n    pass\n\n# Error parser function\ndef parse_web3_error(error) -> InfinityPoolsError:\n    \"\"\"Parse Web3.py exceptions into SDK-specific exceptions\"\"\"\n    error_str = str(error)\n    \n    # Check for revert strings\n    revert_match = re.search(r\"reverted: (.+)$\", error_str)\n    if revert_match:\n        revert_reason = revert_match.group(1)\n        \n        # Map known revert reasons to specific exceptions\n        if \"insufficient liquidity\" in revert_reason.lower():\n            return InsufficientLiquidityError(revert_reason)\n        elif \"slippage\" in revert_reason.lower():\n            return SlippageError(revert_reason)\n        else:\n            return ContractError(revert_reason)\n    \n    # Check for connection issues\n    if \"connection\" in error_str.lower() or \"network\" in error_str.lower():\n        return ConnectionError(f\"Connection error: {error_str}\")\n    \n    # Default to generic error\n    return InfinityPoolsError(f\"Unexpected error: {error_str}\")\n\n# Function to wrap contract calls with error handling\ndef handle_contract_call(func):\n    \"\"\"Decorator to handle contract call errors\"\"\"\n    def wrapper(*args, **kwargs):\n        try:\n            return func(*args, **kwargs)\n        except Exception as e:\n            raise parse_web3_error(e)\n    return wrapper\n```\n\nUpdate the core modules to use this error handling system:\n\n1. Modify `core/connector.py` to catch and translate Web3 errors\n2. Update `core/periphery.py` to use the `handle_contract_call` decorator\n3. Add specific error handling for common contract errors",
      "testStrategy": "1. Write unit tests in `tests/test_errors.py` that verify:\n   - Error translation from Web3 exceptions\n   - Custom exception hierarchy\n   - Error data parsing\n   - Decorator functionality\n2. Test with mock errors and real contract errors\n3. Verify error messages are user-friendly and actionable\n4. Test error handling in all core modules",
      "priority": "medium",
      "dependencies": [
        4,
        7
      ],
      "status": "pending",
      "subtasks": []
    },
    {
      "id": 9,
      "title": "Implement Event Subscription and Parsing",
      "description": "Create a system for subscribing to and parsing Infinity Pools contract events.",
      "details": "Create `utils/events.py` with the following implementation:\n\n```python\nfrom typing import Dict, Any, List, Optional, Callable, Union\nfrom web3 import Web3\nfrom web3.contract import Contract\nfrom ..core.connector import InfinityPoolsConnector\n\nclass EventSubscriber:\n    def __init__(self, connector: InfinityPoolsConnector, contract_name: str = 'InfinityPoolsPeriphery'):\n        self.connector = connector\n        self.w3 = connector.w3\n        self.contract = connector.get_contract(contract_name)\n        self._event_filters = {}\n        self._event_callbacks = {}\n    \n    def subscribe(self, event_name: str, callback: Callable[[Dict[str, Any]], None], \n                 filter_params: Optional[Dict[str, Any]] = None) -> int:\n        \"\"\"Subscribe to a contract event with optional filters\"\"\"\n        if not hasattr(self.contract.events, event_name):\n            raise ValueError(f\"Event {event_name} not found in contract\")\n        \n        event_obj = getattr(self.contract.events, event_name)\n        event_filter = event_obj.create_filter(fromBlock='latest', **filter_params or {})\n        \n        filter_id = id(event_filter)\n        self._event_filters[filter_id] = event_filter\n        self._event_callbacks[filter_id] = callback\n        \n        return filter_id\n    \n    def unsubscribe(self, filter_id: int) -> bool:\n        \"\"\"Unsubscribe from an event\"\"\"\n        if filter_id in self._event_filters:\n            del self._event_filters[filter_id]\n            del self._event_callbacks[filter_id]\n            return True\n        return False\n    \n    def poll_events(self) -> int:\n        \"\"\"Poll for new events and trigger callbacks\"\"\"\n        events_processed = 0\n        \n        for filter_id, event_filter in self._event_filters.items():\n            callback = self._event_callbacks[filter_id]\n            for event in event_filter.get_new_entries():\n                parsed_event = self._parse_event(event)\n                callback(parsed_event)\n                events_processed += 1\n        \n        return events_processed\n    \n    def get_past_events(self, event_name: str, from_block: Union[int, str], \n                        to_block: Union[int, str] = 'latest', \n                        filter_params: Optional[Dict[str, Any]] = None) -> List[Dict[str, Any]]:\n        \"\"\"Get past events within a block range\"\"\"\n        if not hasattr(self.contract.events, event_name):\n            raise ValueError(f\"Event {event_name} not found in contract\")\n        \n        event_obj = getattr(self.contract.events, event_name)\n        events = event_obj.get_logs(fromBlock=from_block, toBlock=to_block, **filter_params or {})\n        \n        return [self._parse_event(event) for event in events]\n    \n    def _parse_event(self, event) -> Dict[str, Any]:\n        \"\"\"Parse a raw event into a more usable format\"\"\"\n        # Convert AttributeDict to regular dict\n        event_dict = dict(event)\n        \n        # Extract and format args\n        args = {}\n        if 'args' in event_dict:\n            args = dict(event_dict['args'])\n        \n        # Format the event data\n        return {\n            'event': event_dict.get('event'),\n            'address': event_dict.get('address'),\n            'block_number': event_dict.get('blockNumber'),\n            'transaction_hash': event_dict.get('transactionHash').hex() if event_dict.get('transactionHash') else None,\n            'log_index': event_dict.get('logIndex'),\n            'args': args\n        }\n\n# Event parser functions for specific events\ndef parse_add_liquidity_event(event: Dict[str, Any]) -> Dict[str, Any]:\n    \"\"\"Parse AddLiquidity event into a more usable format\"\"\"\n    # This is a simplified version - actual implementation would need to\n    # format the event data based on the specific event structure\n    return event\n\ndef parse_swap_event(event: Dict[str, Any]) -> Dict[str, Any]:\n    \"\"\"Parse Swap event into a more usable format\"\"\"\n    # This is a simplified version - actual implementation would need to\n    # format the event data based on the specific event structure\n    return event\n\n# Add more event parsers as needed\n```",
      "testStrategy": "1. Write unit tests in `tests/test_events.py` that verify:\n   - Event subscription and callback handling\n   - Event filtering\n   - Past event retrieval\n   - Event parsing\n   - Unsubscribe functionality\n2. Test with mock events and real contract events\n3. Verify event data is correctly parsed and formatted\n4. Test with different filter parameters",
      "priority": "medium",
      "dependencies": [
        4,
        7
      ],
      "status": "pending",
      "subtasks": []
    },
    {
      "id": 10,
      "title": "Create Documentation and Examples",
      "description": "Develop comprehensive documentation and usage examples for the SDK.",
      "details": "1. Create a comprehensive README.md with:\n   - Project overview and purpose\n   - Installation instructions\n   - Quick start guide\n   - Basic usage examples\n   - Link to full documentation\n\n2. Setup Sphinx documentation:\n   - Create `docs/` directory with Sphinx configuration\n   - Generate API reference documentation\n   - Write tutorial sections\n\n3. Create example scripts in `examples/` directory:\n   - Connection and setup example\n   - Adding liquidity example\n   - Swap and deposit example\n   - Event subscription example\n   - Error handling example\n\n4. Document each module with docstrings following Google style:\n\n```python\ndef function_name(param1: type, param2: type) -> return_type:\n    \"\"\"Short description of function.\n    \n    Longer description explaining the function's purpose, behavior,\n    and any important details.\n    \n    Args:\n        param1: Description of param1\n        param2: Description of param2\n        \n    Returns:\n        Description of return value\n        \n    Raises:\n        ExceptionType: Description of when this exception is raised\n    \n    Examples:\n        >>> function_name('example', 123)\n        'result'\n    \"\"\"\n```\n\n5. Create a user guide covering:\n   - SDK architecture overview\n   - Common use cases and patterns\n   - Best practices\n   - Troubleshooting\n   - Advanced usage\n\n6. Generate and publish documentation to GitHub Pages or ReadTheDocs",
      "testStrategy": "1. Verify documentation builds without errors\n2. Run example scripts to ensure they work as documented\n3. Review API reference for completeness\n4. Check docstring coverage with a tool like interrogate\n5. Have team members review documentation for clarity and accuracy\n6. Test documentation on different platforms (Windows, macOS, Linux)",
      "priority": "medium",
      "dependencies": [
        1,
        2,
        3,
        4,
        5,
        6,
        7,
        8,
        9
      ],
      "status": "pending",
      "subtasks": []
    },
    {
      "id": 11,
      "title": "Implement Tenderly Impersonation for Account Testing",
      "description": "Enhance the SDK with Tenderly impersonation capabilities to enable testing with real user accounts without requiring private keys, specifically supporting account 0x9eAFc0c2b04D96a1C1edAdda8A474a4506752207.",
      "details": "This task involves several key implementation steps:\n\n1. Extend the TenderlyFork class to support account impersonation:\n   - Add methods to impersonate accounts using Tenderly's API\n   - Implement functionality to manage impersonation state\n   - Create helper methods to simplify impersonation setup and teardown\n\n2. Develop methods to create impersonated Web3 instances:\n   - Create factory methods that return Web3 instances configured for impersonation\n   - Ensure proper middleware configuration for impersonated transactions\n   - Handle authentication and authorization with Tenderly's API\n\n3. Update InfinityPoolsConnector for impersonation support:\n   - Add support for custom HTTP headers required by Tenderly\n   - Implement methods to handle impersonated account interactions\n   - Ensure compatibility with existing connector functionality\n\n4. Implement proper error handling:\n   - Create specific exception types for impersonation failures\n   - Add validation for impersonation parameters\n   - Provide clear error messages for troubleshooting\n\n5. Create comprehensive documentation:\n   - Document all new methods and parameters\n   - Provide usage examples for impersonation functionality\n   - Include explanations of Tenderly-specific concepts and requirements\n\nThe implementation should prioritize a clean, intuitive API that makes impersonation straightforward while handling the complexity of Tenderly's requirements internally.",
      "testStrategy": "Testing will verify the complete impersonation functionality through multiple approaches:\n\n1. Unit Tests:\n   - Test TenderlyFork impersonation methods with mocked Tenderly API responses\n   - Verify proper handling of successful and failed impersonation attempts\n   - Test error handling for various edge cases (invalid addresses, API failures)\n\n2. Integration Tests:\n   - Create test fixtures that demonstrate impersonation setup\n   - Implement tests that use impersonated accounts to interact with contracts\n   - Verify that transactions from impersonated accounts are properly processed\n\n3. Specific Account Testing:\n   - Create dedicated tests using the specified account (0x9eAFc0c2b04D96a1C1edAdda8A474a4506752207)\n   - Verify that all SDK functionality works correctly with this impersonated account\n   - Test various contract interactions using the impersonated account\n\n4. End-to-End Workflow Tests:\n   - Create tests that demonstrate complete workflows using impersonation\n   - Test switching between different impersonated accounts\n   - Verify that impersonation works with all existing SDK functionality\n\n5. Documentation Verification:\n   - Review and test all code examples in documentation\n   - Ensure documentation accurately reflects implementation\n   - Verify that error messages match documentation\n\nAll tests should be automated and included in the CI pipeline to ensure ongoing functionality.",
      "status": "done",
      "dependencies": [],
      "priority": "high",
      "subtasks": []
    },
    {
      "id": 12,
      "title": "Task #12: Develop Functional Test Framework with Tenderly Impersonation for SDK",
      "description": "Create a comprehensive functional test framework that leverages Tenderly impersonation to test SDK functions with real accounts, without requiring private keys.",
      "details": "This task involves building a robust functional test framework for the SDK using Tenderly impersonation capabilities implemented in Task #11. The implementation should include:\n\n1. Create a base functional test class (e.g., `BaseFunctionalTest`) that provides:\n   - Common setup and teardown methods\n   - Fixtures for Tenderly impersonation\n   - Utilities for account management and transaction verification\n   - Helper methods for common assertions and validations\n   - Configuration handling for test environments\n\n2. Implement functional tests for `add_liquidity`:\n   - Test various liquidity addition scenarios with different parameters\n   - Verify token transfers and position updates\n   - Test edge cases including min/max tick ranges\n   - Handle both new position creation and existing position expansion\n\n3. Implement functional tests for `remove_liquidity`:\n   - Test partial and complete liquidity removal\n   - Verify correct token amounts returned\n   - Test across different position configurations\n   - Validate position state after removal\n\n4. Set up extensible test structure for additional SDK functions:\n   - Create test class templates for `collect_fees`, `swap_exact_input`, `swap_exact_output`, `get_position_details`, and `get_pool_info`\n   - Implement shared test utilities that can be reused across function tests\n   - Design parameterized test cases that can handle various input configurations\n\n5. Configure test runner integration:\n   - Implement a mechanism to run tests with the `--run-integration` flag\n   - Ensure tests can be run in isolation or as part of a full test suite\n   - Add proper logging and reporting for test results\n\nThe implementation should follow best practices for test organization, including proper setup/teardown, clear test case naming, and comprehensive assertions. Tests should be designed to be maintainable and extensible as the SDK evolves.",
      "testStrategy": "The test strategy for this task should include:\n\n1. Code Review:\n   - Verify the base test class implements all required utilities and fixtures\n   - Ensure test organization follows best practices and is maintainable\n   - Check that Tenderly impersonation is properly integrated\n   - Confirm test coverage for various scenarios and edge cases\n\n2. Unit Testing:\n   - Run individual test cases to verify they correctly test specific SDK functions\n   - Validate that test assertions properly check expected outcomes\n   - Ensure test utilities function as expected\n\n3. Integration Testing:\n   - Run the full test suite with the `--run-integration` flag\n   - Verify tests successfully impersonate the specified account (0x9eAFc0c2b04D96a1C1edAdda8A474a4506752207)\n   - Confirm tests interact with actual contracts on the blockchain\n   - Validate that all SDK functions are tested with real-world scenarios\n\n4. Validation Criteria:\n   - All tests should pass consistently when run with the integration flag\n   - Test coverage should meet or exceed 90% for the SDK functions being tested\n   - Tests should complete within a reasonable time frame (< 5 minutes for the full suite)\n   - Test reports should provide clear information about test results and any failures\n\n5. Documentation:\n   - Verify that the test framework is well-documented with usage examples\n   - Ensure comments explain test scenarios and expected outcomes\n   - Confirm README includes instructions for running tests with the integration flag\n\nThe implementation will be considered complete when all tests pass consistently, provide adequate coverage, and follow the specified structure for extensibility.",
      "status": "done",
      "dependencies": [],
      "priority": "high",
      "subtasks": []
    },
    {
      "id": 13,
      "title": "Implement Tenderly Impersonation Functional Test Framework",
      "description": "Create a comprehensive functional testing framework that leverages Tenderly impersonation to test SDK functions with real accounts and state on mainnet forks.",
      "details": "The framework should support testing all core SDK functions including add_liquidity, remove_liquidity, collect_fees, swap_exact_input, swap_exact_output, get_position_details, and get_pool_info. Tests should be able to impersonate specific accounts to interact with real positions and pools without requiring private keys.",
      "testStrategy": "",
      "status": "pending",
      "dependencies": [],
      "priority": "high",
      "subtasks": [
        {
          "id": 1,
          "title": "Create Simple Impersonation Test Script",
          "description": "Develop a simple script to manually test the impersonation functionality with a specific SDK function",
          "details": "Create a standalone script that uses the Tenderly impersonation feature to execute a simple SDK function call (e.g., getting account balances or position details). This will verify that the core impersonation functionality works correctly before building more complex tests. The script should be well-documented to serve as a reference for future test development.",
          "status": "done",
          "dependencies": [],
          "parentTaskId": 13
        },
        {
          "id": 2,
          "title": "Update Base Functional Test Class",
          "description": "Refine the base functional test class to properly initialize the SDK and provide common utilities",
          "details": "Modify the BaseTenderlyFunctionalTest class to correctly initialize the SDK with the necessary parameters (connector and periphery address). Add helper methods for common operations like getting contract instances, checking balances, and handling transactions. Ensure the impersonated_connector fixture properly sets up the connector with the correct headers and configuration.",
          "status": "done",
          "dependencies": [],
          "parentTaskId": 13
        },
        {
          "id": 3,
          "title": "Implement Add Liquidity Functional Test",
          "description": "Create a functional test for the add_liquidity SDK function using Tenderly impersonation",
          "details": "Update the add_liquidity functional test to match the actual SDK implementation. Ensure it correctly handles token approvals, parameter formatting, and result verification. The test should use real token addresses and pools from mainnet, with appropriate safety measures to use small amounts. Include proper error handling and detailed logging to aid in debugging.",
          "status": "done",
          "dependencies": [
            "13.2"
          ],
          "parentTaskId": 13
        },
        {
          "id": 4,
          "title": "Implement Remove Liquidity Functional Test",
          "description": "Create a functional test for the remove_liquidity SDK function using Tenderly impersonation",
          "details": "Update the remove_liquidity functional test to match the actual SDK implementation. The test should identify existing positions owned by the impersonated account, verify their details, and attempt to remove liquidity. Include proper validation of transaction results and position state changes. Handle edge cases like positions with zero liquidity or fully drained positions.",
          "status": "pending",
          "dependencies": [
            "13.2"
          ],
          "parentTaskId": 13
        },
        {
          "id": 5,
          "title": "Implement Swap Functions Functional Tests",
          "description": "Create functional tests for swap_exact_input and swap_exact_output SDK functions",
          "details": "Develop functional tests for the swap functions using Tenderly impersonation. Tests should verify that swaps execute correctly with the impersonated account, including token approvals, parameter formatting, and result verification. Use real token pairs from mainnet with appropriate safety measures to use small amounts. Include proper error handling and detailed logging to aid in debugging.",
          "status": "pending",
          "dependencies": [
            "13.2"
          ],
          "parentTaskId": 13
        },
        {
          "id": 6,
          "title": "Implement Multicall/Batch Actions Test",
          "description": "Create a functional test for the multicall/batch_actions pattern using Tenderly impersonation",
          "details": "Develop a functional test that demonstrates the multicall/batch_actions pattern identified by function selector `0xac9650d8` on the InfinityPoolsProxy. The test should batch multiple operations (e.g., approve and open position) into a single transaction using the impersonated account. Include proper validation of transaction results and state changes. This test is particularly important as it validates a core protocol pattern mentioned in the project memories.",
          "status": "pending",
          "dependencies": [
            "13.2"
          ],
          "parentTaskId": 13
        },
        {
          "id": 7,
          "title": "Create Documentation for Tenderly Impersonation Testing",
          "description": "Document the Tenderly impersonation testing framework and best practices",
          "details": "Create comprehensive documentation for the Tenderly impersonation testing framework, including setup instructions, usage examples, and best practices. The documentation should cover how to configure environment variables, how to select accounts for impersonation, how to handle gas estimation issues, and how to troubleshoot common problems. Include examples of how to use the framework for testing different SDK functions and how to extend it for new functions.",
          "status": "pending",
          "dependencies": [],
          "parentTaskId": 13
        }
      ]
    }
  ]
}